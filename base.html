<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Title of the document</title>
    <script src="vue.js"></script>
    <style>
      body {
        --color-one: rgb(81,130,187);
        --color-two: rgb(237,242,248);
        --color-three: rgb(186, 205, 228);
        --color-four: rgb(245, 227, 83);
        --header-height: 3em;
      }
      div.header {
        display: flex;
        flex-direction: row;
        height: var(--header-height);
        position: relative;
        font-size: 1.5em;
        background: var(--color-one);
        border: 1px solid var(--color-one);
        align-items: center;
        color: white;
        border-radius: 0.25em 0 0 0.25em;
        overflow: hidden;
      }
      div.header div.logo {
        flex: 0 0 auto;
        height: var(--header-height);
        width: 4em;
        text-align: center;
        line-height: var(--header-height);
        border-right: 1px solid white;
        border-radius: 0.25em;
        overflow: hidden;
        padding-right: 0.25em;
        background: rgb(13,95,169);
          color: #ddd;
      }
      div.header div.title {
        padding-left: 0.5em;
        font-size: 0.95em;
      }
      div.header div.number {
        flex: 0 0 10%;
        background: var(--color-four);
        color: var(--color-one);
        height: 100%;
        text-align: center;
        line-height: var(--header-height);
        margin-left: auto;
      }
      div.instructions {
        padding: 1em;
          font-size: 0.75em;
      }
      div.checkbox {
        display: flex;
        flex-flow: row;
        flex-wrap: nowrap;
      }
      label.checkbox {
        flex: 1 1 auto;
      }
      input[type="checkbox"].checkbox {
        flex: 1 1 auto;
      }
      table {
        border: 1px solid var(--color-one);
      }
      td {
        border: 0px solid white;
      }

      td.questionNumber {
        padding: 0.5em;
        font-size: 1.25em;
      }

      td.questionText {
        padding-left: 0.5em;
      }

      td.questionPartText {
        padding-left: 1em;
      }

      th {
        background: var(--color-one);
        border: 1px solid white;
        color: white;
      }
      tr:nth-child(even) {
        background-color: var(--color-three);
      }
      tr:nth-child(odd) {
        background-color: var(--color-two);
      }

      button.export {
        font-variant: small-caps;
        font-size: 125%;
          background: lightgreen;
      }
      button.reset {
        font-variant: small-caps;
        font-size: 125%;
        background: orange;
      }
      button.undo {
        font-variant: small-caps;
        font-size: 125%;
        background: lightblue;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <select v-model="activeCard" @change="cardSelected">
        <option v-for="(card, cIdx) in cards" :value="cIdx">{{card.number}} : {{ card.name }}</option>
      </select>
      <div class="header">
        <div class="logo"><i>logo</i></div>
        <div class="title">{{ survey.title }}</div>
        <div class="number">{{ survey.number }}</div>
      </div>

      <div class="instructions">
        <b>Instructions</b>: {{ survey.instructions }}
      </div>

      <table v-for="(section, sIdx) in survey.sections">
        <template v-if="section.observables.length > 1">
          <thead>
            <tr>
              <th rowspan="2" colspan="2">{{ section.header }}</th>
              <th rowspan="2" colspan="1" v-for="observable in section.observables">{{ observable }}</th>
              <th rowspan="1" colspan="2"> Summary Of Observations </th>
            </tr>
            <tr>
              <th>Yes</th>
              <th>Total Observed</th>
            </tr>
          </thead>

          <tfoot v-if="isFinalSection(survey, section)">
            <th :colspan="section.observables.length + 2">Total Yes and Total Observed</th>
            <td align="center"> {{ countTotalObserved(survey, "Yes") }} </td>
            <td align="center"> {{ countTotalObserved(survey) }}</td>
          </tfoot>

          <tbody>
            <tr v-for="(q, qIdx) in section.questions">
              <td class="questionNumber">{{ q.number }}</td>
              <td class="questionText" >{{ q.text }}</td>
              <template v-for="(o, oIdx) in q.observations">
                <td>
                  <template v-for="(c, cIdx) in q.choices">
                    <div class="checkbox">
                      <input class="checkbox" id="checkbox_id(qIdx, oIdx, cIdx)" type="checkbox" v-model="o[c]" @change="enforceChoice(o, c)">
                      <label class="checkbox" for="checkbox_id(qIdx, oIdx, cIdx)" >{{ c }}</label>
                    </div>
                  </template>
                </td>
              </template>
              <td align="center">
                {{ countQuestionObservation(q, "Yes") }}
              </td>
              <td align="center">
                {{ countQuestionObserved(q) }}
              </td>
            </tr>
          </tbody>
        </template>

        <template v-else>
          <thead>
            <tr>
              <th rowspan="1" colspan="2">{{ section.header }}</th>
              <th rowspan="1" :colspan="section.choices.length"> Summary Of Observations </th>
            </tr>
          </thead>

          <tfoot v-if="isFinalSection(survey, section)">
            <th colspan="2">Total</th>
            <td align="center" v-for="choice in section.choices">
              {{ countTotalObserved(survey, choice) }}
            </td>
          </tfoot>

          <tbody>
            <template v-for="(q, qIdx) in section.questions">
              <template v-if="q.choices">
                <tr>
                  <td class="questionNumber">{{ q.number }}</td>
                  <td class="questionText" >{{ q.text }}</td>
                  <template v-for="(o, oIdx) in q.observations">
                    <td v-for="(c, cIdx) in q.choices">
                      <div class="checkbox">
                        <input class="checkbox" id="checkbox_id(qIdx, 0, cIdx)" type="checkbox" v-model="o[c]" @change="enforceChoice(o, c)">
                        <label class="checkbox" for="checkbox_id(qIdx, 0, cIdx)" >{{ c }}</label>
                      </div>
                    </td>
                  </template>
                </tr>
              </template>
              <template v-if="q.parts">
                <tr>
                  <td class="questionNumber" :rowspan="q.parts.length+1">{{ q.number }}</td>
                  <td class="questionText">{{ q.text }}</td>
                </tr>
                <tr v-for="part in q.parts">
                  <td class="questionPartText" >{{part.number}}. {{part.text}}</td>
                  <template v-for="(o, oIdx) in part.observations">
                    <td v-for="(c, cIdx) in part.choices">
                      <div class="checkbox">
                        <input class="checkbox" id="checkbox_id(qIdx, 0, cIdx)" type="checkbox" v-model="o[c]" @change="enforceChoice(o, c)">
                        <label class="checkbox" for="checkbox_id(qIdx, 0, cIdx)" >{{ c }}</label>
                      </div>
                    </td>
                  </template>
                </tr>
              </template>
            </template>
          </tbody>
        </template>
      </table>
      <button v-if="canExport" class="export" @click="exportData">export</button>
      <button v-if="canReset" class="reset" @click="resetData">reset</button>
      <button v-if="canUndo" class="undo" @click="undoReset">undo reset</button>
    </div>
    <script>
      /*INSERT*/
      function* QuestionNumberGenerator() {
        var value = 1;
        while(true) {
          yield value++;
        }
      };

      function generateObservation(q) {
        const observation = {};
        q.choices.forEach( (choice) => observation[choice] = false );
        return observation;
      }

      function generateQuestion(observables, question, numberGenerator) {
        if (question.choices) {
          const observations = observables.map( (o) => generateObservation(question) );
          const choices = question.choices.map( (c) => c );
          const number = numberGenerator.next().value;
          const text = question.text;

          return {number, text, choices, observations}
        }

        if (question.parts) {
          const observations = [];
          const partNumberGenerator = QuestionNumberGenerator();
          const parts = question.parts.map( (q) => generateQuestion(observables, q, partNumberGenerator) );
          const number = numberGenerator.next().value;
          const text = question.text;

          return {number, text, parts, observations}
        }
      }

      function validateChoiceSet(choices, question) {
        if (question.choices) {
          const mismatched = question.choices.filter( (c, idx) => choices[idx] !== c );
          return mismatched.length > 0;
        }
        if (question.parts) {
          const mismatched = question.parts.filter( (q) => validateChoiceSet(choices, q) );
          return mismatched.length > 0;
        }
      }

      function generateModel(survey) {
        const questionNumberGenerator = QuestionNumberGenerator();

        const sections = survey.sections.map( (s, sIdx) => {
          const header = s.header;
          const observables = survey.observables.map( (label) => label );
          const questions = s.questions.map( (q) => generateQuestion(observables, q, questionNumberGenerator) );
          const choices = s.choiceSet.map( (choice) => choice );

          /* Check for well-formed data */
          const mismatched = questions.filter( (q) => validateChoiceSet(choices, q) );
          if (mismatched.length > 0) {
            throw new Error("Error: One or more question's choices do not match the allowed choiceSet.");
          }

          return {header, questions, choices, observables};
        });

        return sections;
      }

      var app = new Vue({
        el: '#app',
        data: {
          activeCard: 16,
          backup: false,
          survey: false,
        },
        computed: {
          canReset() {
            return this.countTotalObserved(this.survey) > 0;
          },
          canUndo() {
            return this.backup !== false && this.countTotalObserved(this.survey) === 0;
          },
          canExport() {
            return this.countTotalObserved(this.survey) > 0;
          }
        },
        methods: {
          isFinalSection(survey, section) {
            return survey.sections.indexOf(section) === (survey.sections.length - 1);
          },
          label: (qIdx,rIdx,yesno) => `question-${qIdx}-observable-${rIdx}-${yesno}`,
          enforceChoice(observation, which) {
            const others = Object.keys(observation).filter( (key) => key !== which );
            others.forEach( (other) => observation[other] = false );
          },
          countTotalObserved(survey, choice) {
            if (choice) {
              return survey.sections.reduce( (acc, s) => acc + this.countSectionObservation(s, choice), 0)
            } else {
              return survey.sections.reduce( (acc, q) => acc + this.countSectionObserved(q), 0)
            }
          },
          countQuestionObservation(q, choice) {
            if (q.choices) {
              return q.observations.filter( (r) => r[choice] ).length
            }
            if (q.parts) {
              return q.parts.reduce( (acc, p) => acc + this.countQuestionObservation(p, choice), 0);
            }
          },
          countQuestionObserved(q) {
            if (q.choices) {
              return q.observations.filter( (r) => r["Yes"] || r["No"] ).length;
            }
            if (q.parts) {
              return q.parts.reduce( (acc, p) => acc + this.countQuestionObserved(q), 0 );
            }
          },
          countSectionObservation(s, choice) {
            return s.questions.reduce( (acc, q) => acc + this.countQuestionObservation(q, choice), 0);
          },
          countSectionObserved(s) {
            return s.questions.reduce( (acc, q) => acc + this.countQuestionObserved(q), 0);
          },
          csvHeader() {
            const columns = [
              "Observation Number",
              "Observation Category",
              ...this.observables,
              "'Yes' Observed",
              "Total Observed"
            ]
            return columns.join(",");
          },
          csvData() {
            return this.questions.map( (q, idx) => {
              const columns = [
                `${q.number}`,
                `"${q.text}"`,
                ...q.observables.map( (r) => {
                  return r["Yes"] ? "1" : "0";
                }),
                this.countQuestionObservation(q, "Yes"),
                this.countQuestionObserved(q),
                ];
              return columns.join(',');
            })
          },
          generateCSV() {
            const lines = [this.csvHeader(), ... this.csvData()];
            return lines.join("\n");
          },
          exportData() {
            const filename="demo.csv";
            const text = this.generateCSV();
            var element = document.createElement('a');
            element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
            element.setAttribute('download', filename);

            element.style.display = 'none';
            document.body.appendChild(element);

            element.click();

            document.body.removeChild(element);
          },
          populate(card) {
            const title = card.title;
            const instructions = card.instructions;
            const number = card.number;
            const sections = generateModel(card);

            return {title, instructions, number, sections}
          },
          resetData() {
            this.backup = this.survey;
            this.survey = this.populate(cards[this.activeCard]);
          },
          undoReset() {
            this.survey = this.backup;
            this.backup = false;
          },
          cardSelected() {
            this.survey = this.populate(cards[this.activeCard]);
            this.backu = false;
          },
        },
        created() {
          this.survey = this.populate(cards[this.activeCard]);
          this.backup = false;
        }
      });
    </script>
  </body>
</html>
